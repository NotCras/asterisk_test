<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>asterisk_test.asterisk_average API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>asterisk_test.asterisk_average</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from numpy import sin, cos, pi, linspace, sqrt, abs, arctan2, zeros, floor, nan, radians
import pandas as pd
import matplotlib.pyplot as plt
from asterisk_trial import AsteriskTrialData
from asterisk_plotting import AsteriskPlotting
import pdb


class AveragedTrial(AsteriskTrialData):
    rotations = {&#34;a&#34;: 270, &#34;b&#34;: 315, &#34;c&#34;: 0, &#34;d&#34;: 45, &#34;e&#34;: 90,
                 &#34;f&#34;: 135, &#34;g&#34;: 180, &#34;h&#34;: 225}

    def __init__(self):
        super(AveragedTrial, self).__init__()  # makes an empty AsteriskTrialData object

        self.subject = []
        self.names = []  # names of trials averaged
        self.averaged_trials = []  # actual AsteriskTrialData objects that were averaged
        # self.pose_average = []  # maybe just use poses
        self.pose_sd = None

    def get_poses_sd(self):
        &#34;&#34;&#34;
        Separates poses into x, y, theta for easy plotting.
        &#34;&#34;&#34;
        # get the poses
        x = self.pose_sd[&#34;x&#34;]
        y = self.pose_sd[&#34;y&#34;]
        twist = self.pose_sd[&#34;rmag&#34;]

        return_x = pd.Series.to_list(x.dropna())
        return_y = pd.Series.to_list(y.dropna())
        return_twist = pd.Series.to_list(twist.dropna())

        return return_x, return_y, return_twist

    def _get_points(self, points, x_val, bounds):
        &#34;&#34;&#34;
        Function which gets all the points that fall in a specific value range
        :param points: list of all points to sort
        :param x_val: x value to look around
        :param bounds: bounds around x value to look around
        &#34;&#34;&#34;
        hi_val = x_val + bounds
        lo_val = x_val - bounds

        #print(f&#34;t_pose: {x_val} +/- {bounds}&#34;)

        points_in_bounds = points[(points[&#39;x&#39;] &gt; lo_val) &amp; (points[&#39;x&#39;] &lt; hi_val)]

        return points_in_bounds

    def _rotate_points(self, points, ang):
        &#34;&#34;&#34;
        rotate points so they are horizontal
        :param points: points is a dataframe with &#39;x&#39;, &#39;y&#39;, &#39;rmag&#39; columns
        :param ang: angle to rotate data
        &#34;&#34;&#34;
        rad = radians(ang)
        rotated_line = pd.DataFrame(columns=[&#39;x&#39;, &#39;y&#39;, &#39;rmag&#39;])

        for p in points.iterrows():
            x = p[1][&#39;x&#39;]
            y = p[1][&#39;y&#39;]
            new_x = x*cos(rad) - y*sin(rad)
            new_y = y*cos(rad) + x*sin(rad)
            rotated_line = rotated_line.append({&#34;x&#34;: new_x, &#34;y&#34;: new_y, &#34;rmag&#34;: p[1][&#39;rmag&#39;]}, ignore_index=True)

        return rotated_line

    def make_average_line(self, trials):
        &#34;&#34;&#34;
        Average the path of 2 or more AsteriskTrialObjects. Produces average and standard deviations.
        Saves this data on the object itself.
        :param trials: list of trials to average
        &#34;&#34;&#34;

        # collect the asterisktrialdata objects
        self.names = []  # if rerunning an average with same object, make sure these lists are empty
        self.averaged_trials = []
        for t_n in trials:
            self.names.append(t_n.generate_name())
            self.averaged_trials.append(t_n)

        # first take attributes of first asterisktrialdata object and take its attributes
        trial = self.averaged_trials[0]
        self.subject = trial.subject  # TODO: add more subjects, make this a list? -&gt; will affect other func too
        self.trial_translation = trial.trial_translation
        self.trial_rotation = trial.trial_rotation
        self.trial_num = trial.trial_num
        self.target_line = trial.target_line

        # get all the data
        data_points = pd.DataFrame()  # makes an empty dataframe
        for t in self.averaged_trials:
            data_points = data_points.append(t.poses)

        # rotate the line so we can do everything based on the x axis
        r_target_x, r_target_y = AsteriskPlotting.get_c(100)
        rotated_target_line = np.column_stack((r_target_x, r_target_y))
        rotated_data = self._rotate_points(data_points, self.rotations[self.trial_translation])

        avg_line = pd.DataFrame()
        avg_std = pd.DataFrame()

        # now we go through averaging
        for t in rotated_target_line:
            t_x = t[0]
            points = self._get_points(rotated_data, t_x, 0.05)
            # TODO: 0.05 is arbitrary... make bounds scale with resolution of target_line?
            averaged_point = points.mean(axis=0)  # averages each column in DataFrame
            std_point = points.std(axis=0)
            avg_line = avg_line.append(averaged_point, ignore_index=True)
            avg_std = avg_std.append(std_point, ignore_index=True)

        # rotate everything back
        correct_avg = self._rotate_points(avg_line, -1 * self.rotations[self.trial_translation])
        correct_std = self._rotate_points(avg_std, -1 * self.rotations[self.trial_translation])

        self.poses = correct_avg
        self.pose_sd = correct_std  # TODO: std confidence intervals don&#39;t seem to match up well, need to investigate

        print(f&#34;Averaged: {self.subject}_{self.trial_translation}_{self.trial_rotation}&#34;)

        # now filter and run fd
        self.moving_average()
        # self.translation_fd, self.rotation_fd = self.calc_frechet_distance()  # TODO: broken for avg, investigate!

        return correct_avg

    def avg_debug_plot(self, show_plot=True, save_plot=False):
        &#34;&#34;&#34;
        Plots one specific average together with all the data that was averaged for sanity checking the average.
        :param show_plot: flag to show plot. Default is true
        :param save_plot: flat to save plot as a file. Default is False
        &#34;&#34;&#34;
        # TODO: show all target line points on plot, and show at least one averaging interval
        # plot the trials
        for i, t in enumerate(self.averaged_trials):
            # TODO: make it not use poses later
            plt.plot(t.poses[&#39;x&#39;], t.poses[&#39;y&#39;], label=f&#34;trial {i}&#34;, alpha=0.5, color=&#34;xkcd:blue grey&#34;)

        # plot average
        plt.plot(self.poses[&#39;x&#39;], self.poses[&#39;y&#39;], label=&#34;avg&#34;, color=&#34;xkcd:burnt orange&#34;)
        self.plot_sd(&#34;xkcd:burnt orange&#34;)

        if save_plot:
            plt.savefig(f&#34;pics/avgdebug_{self.subject}_{self.hand.get_name()}_{self.trial_translation}_&#34;
                        f&#34;{self.trial_rotation}_{self.trial_number}.jpg&#34;, format=&#39;jpg&#39;)
            # name -&gt; tuple: subj, hand  names
            print(&#34;Figure saved.&#34;)
            print(&#34; &#34;)

        if show_plot:
            plt.legend()
            plt.show()

    def plot_sd(self, color, use_filtered=False):
        &#34;&#34;&#34;
        plot the standard deviations as a confidence interval around the averaged line
        :param color: color for sd polygon, must be compatible with matplotlib.
        :param use_filtered: enables option to use filtered or unfiltered data. Defaults to False
        &#34;&#34;&#34;
        data_x, data_y, data_t = self.get_poses(use_filtered)
        sd_x, sd_y, sd_t = self.get_poses_sd()

        # necessary for building the polygon
        r_x = list(reversed(data_x))
        r_y = list(reversed(data_y))
        r_sx = list(reversed(sd_x))
        r_sy = list(reversed(sd_y))

        poly = []
        for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
            pt = [dx + sx, dy + sy]
            poly.append(pt)

        for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
            pt = [dx - sx, dy - sy]
            poly.append(pt)

        # TODO: figure out correct setup later, it has something to do with the funky confidence intervals
        # if avg_trial.trial_translation in [&#34;c&#34;, &#34;g&#34;]:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sx, dy + sy]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #     #for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sx, dy - sy]
        #         poly.append(pt)
        #
        # elif avg_trial.trial_translation in [&#34;a&#34;, &#34;e&#34;]:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sy, dy]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sy, dy]
        #         poly.append(pt)
        #
        # else:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sy, dy + sx]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sy, dy - sx]
        #         poly.append(pt)

        polyg = plt.Polygon(poly, color=color, alpha=0.4)
        plt.gca().add_patch(polyg)


if __name__ == &#39;__main__&#39;:
    # demo and test
    test1 = AsteriskTrialData(&#39;sub1_2v2_c_n_1.csv&#39;)
    test2 = AsteriskTrialData(&#39;sub1_2v2_c_n_2.csv&#39;)
    test3 = AsteriskTrialData(&#39;sub1_2v2_c_n_3.csv&#39;)

    test4 = AsteriskTrialData(&#39;sub2_2v2_c_n_1.csv&#39;)
    test5 = AsteriskTrialData(&#39;sub2_2v2_c_n_2.csv&#39;)
    test6 = AsteriskTrialData(&#39;sub2_2v2_c_n_3.csv&#39;)

    lines = [test1, test2, test3, test4, test5, test6]

    avgln = AveragedTrial()
    avgln.make_average_line(lines)

    avgln.avg_debug_plot()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="asterisk_test.asterisk_average.AveragedTrial"><code class="flex name class">
<span>class <span class="ident">AveragedTrial</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent a single asterisk test trial.
:param file_name: - name of the file that you want to import data from</p>
<p>Class contains:
:attribute hand: - hand object with info for hand involved in the trial (see above)
:attribute subject_num: - integer value for subject number
:attribute direction: - single lettered descriptor for which direction the object travels in for this trial
:attribute trial_type: - indicates one-step or two-step trial as a string (None, Plus15, Minus15)
:attribute trial_num: - integer number of the trial</p>
<p>:attribute poses: - pandas dataframe containing the object's trajectory (as floats)
:attribute filtered: - boolean that indicates whether trial has been filtered or not
:attribute ideal_poses: - pandas dataframe containing the 'perfect trial' line that we will compare our trial to using Frechet Distance.
This 'perfect trial' line is a line that travels in the trial direction (with no deviations) to the max travel distance the
trial got to in the respective direction. This is denoted as the projection of the object trajectory on the direction</p>
<p>:attribute total_distance: - float value
:attribute frechet_distance: - float value
:attribute dist_along_translation: - float
:attribute dist_along_twist: - float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AveragedTrial(AsteriskTrialData):
    rotations = {&#34;a&#34;: 270, &#34;b&#34;: 315, &#34;c&#34;: 0, &#34;d&#34;: 45, &#34;e&#34;: 90,
                 &#34;f&#34;: 135, &#34;g&#34;: 180, &#34;h&#34;: 225}

    def __init__(self):
        super(AveragedTrial, self).__init__()  # makes an empty AsteriskTrialData object

        self.subject = []
        self.names = []  # names of trials averaged
        self.averaged_trials = []  # actual AsteriskTrialData objects that were averaged
        # self.pose_average = []  # maybe just use poses
        self.pose_sd = None

    def get_poses_sd(self):
        &#34;&#34;&#34;
        Separates poses into x, y, theta for easy plotting.
        &#34;&#34;&#34;
        # get the poses
        x = self.pose_sd[&#34;x&#34;]
        y = self.pose_sd[&#34;y&#34;]
        twist = self.pose_sd[&#34;rmag&#34;]

        return_x = pd.Series.to_list(x.dropna())
        return_y = pd.Series.to_list(y.dropna())
        return_twist = pd.Series.to_list(twist.dropna())

        return return_x, return_y, return_twist

    def _get_points(self, points, x_val, bounds):
        &#34;&#34;&#34;
        Function which gets all the points that fall in a specific value range
        :param points: list of all points to sort
        :param x_val: x value to look around
        :param bounds: bounds around x value to look around
        &#34;&#34;&#34;
        hi_val = x_val + bounds
        lo_val = x_val - bounds

        #print(f&#34;t_pose: {x_val} +/- {bounds}&#34;)

        points_in_bounds = points[(points[&#39;x&#39;] &gt; lo_val) &amp; (points[&#39;x&#39;] &lt; hi_val)]

        return points_in_bounds

    def _rotate_points(self, points, ang):
        &#34;&#34;&#34;
        rotate points so they are horizontal
        :param points: points is a dataframe with &#39;x&#39;, &#39;y&#39;, &#39;rmag&#39; columns
        :param ang: angle to rotate data
        &#34;&#34;&#34;
        rad = radians(ang)
        rotated_line = pd.DataFrame(columns=[&#39;x&#39;, &#39;y&#39;, &#39;rmag&#39;])

        for p in points.iterrows():
            x = p[1][&#39;x&#39;]
            y = p[1][&#39;y&#39;]
            new_x = x*cos(rad) - y*sin(rad)
            new_y = y*cos(rad) + x*sin(rad)
            rotated_line = rotated_line.append({&#34;x&#34;: new_x, &#34;y&#34;: new_y, &#34;rmag&#34;: p[1][&#39;rmag&#39;]}, ignore_index=True)

        return rotated_line

    def make_average_line(self, trials):
        &#34;&#34;&#34;
        Average the path of 2 or more AsteriskTrialObjects. Produces average and standard deviations.
        Saves this data on the object itself.
        :param trials: list of trials to average
        &#34;&#34;&#34;

        # collect the asterisktrialdata objects
        self.names = []  # if rerunning an average with same object, make sure these lists are empty
        self.averaged_trials = []
        for t_n in trials:
            self.names.append(t_n.generate_name())
            self.averaged_trials.append(t_n)

        # first take attributes of first asterisktrialdata object and take its attributes
        trial = self.averaged_trials[0]
        self.subject = trial.subject  # TODO: add more subjects, make this a list? -&gt; will affect other func too
        self.trial_translation = trial.trial_translation
        self.trial_rotation = trial.trial_rotation
        self.trial_num = trial.trial_num
        self.target_line = trial.target_line

        # get all the data
        data_points = pd.DataFrame()  # makes an empty dataframe
        for t in self.averaged_trials:
            data_points = data_points.append(t.poses)

        # rotate the line so we can do everything based on the x axis
        r_target_x, r_target_y = AsteriskPlotting.get_c(100)
        rotated_target_line = np.column_stack((r_target_x, r_target_y))
        rotated_data = self._rotate_points(data_points, self.rotations[self.trial_translation])

        avg_line = pd.DataFrame()
        avg_std = pd.DataFrame()

        # now we go through averaging
        for t in rotated_target_line:
            t_x = t[0]
            points = self._get_points(rotated_data, t_x, 0.05)
            # TODO: 0.05 is arbitrary... make bounds scale with resolution of target_line?
            averaged_point = points.mean(axis=0)  # averages each column in DataFrame
            std_point = points.std(axis=0)
            avg_line = avg_line.append(averaged_point, ignore_index=True)
            avg_std = avg_std.append(std_point, ignore_index=True)

        # rotate everything back
        correct_avg = self._rotate_points(avg_line, -1 * self.rotations[self.trial_translation])
        correct_std = self._rotate_points(avg_std, -1 * self.rotations[self.trial_translation])

        self.poses = correct_avg
        self.pose_sd = correct_std  # TODO: std confidence intervals don&#39;t seem to match up well, need to investigate

        print(f&#34;Averaged: {self.subject}_{self.trial_translation}_{self.trial_rotation}&#34;)

        # now filter and run fd
        self.moving_average()
        # self.translation_fd, self.rotation_fd = self.calc_frechet_distance()  # TODO: broken for avg, investigate!

        return correct_avg

    def avg_debug_plot(self, show_plot=True, save_plot=False):
        &#34;&#34;&#34;
        Plots one specific average together with all the data that was averaged for sanity checking the average.
        :param show_plot: flag to show plot. Default is true
        :param save_plot: flat to save plot as a file. Default is False
        &#34;&#34;&#34;
        # TODO: show all target line points on plot, and show at least one averaging interval
        # plot the trials
        for i, t in enumerate(self.averaged_trials):
            # TODO: make it not use poses later
            plt.plot(t.poses[&#39;x&#39;], t.poses[&#39;y&#39;], label=f&#34;trial {i}&#34;, alpha=0.5, color=&#34;xkcd:blue grey&#34;)

        # plot average
        plt.plot(self.poses[&#39;x&#39;], self.poses[&#39;y&#39;], label=&#34;avg&#34;, color=&#34;xkcd:burnt orange&#34;)
        self.plot_sd(&#34;xkcd:burnt orange&#34;)

        if save_plot:
            plt.savefig(f&#34;pics/avgdebug_{self.subject}_{self.hand.get_name()}_{self.trial_translation}_&#34;
                        f&#34;{self.trial_rotation}_{self.trial_number}.jpg&#34;, format=&#39;jpg&#39;)
            # name -&gt; tuple: subj, hand  names
            print(&#34;Figure saved.&#34;)
            print(&#34; &#34;)

        if show_plot:
            plt.legend()
            plt.show()

    def plot_sd(self, color, use_filtered=False):
        &#34;&#34;&#34;
        plot the standard deviations as a confidence interval around the averaged line
        :param color: color for sd polygon, must be compatible with matplotlib.
        :param use_filtered: enables option to use filtered or unfiltered data. Defaults to False
        &#34;&#34;&#34;
        data_x, data_y, data_t = self.get_poses(use_filtered)
        sd_x, sd_y, sd_t = self.get_poses_sd()

        # necessary for building the polygon
        r_x = list(reversed(data_x))
        r_y = list(reversed(data_y))
        r_sx = list(reversed(sd_x))
        r_sy = list(reversed(sd_y))

        poly = []
        for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
            pt = [dx + sx, dy + sy]
            poly.append(pt)

        for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
            pt = [dx - sx, dy - sy]
            poly.append(pt)

        # TODO: figure out correct setup later, it has something to do with the funky confidence intervals
        # if avg_trial.trial_translation in [&#34;c&#34;, &#34;g&#34;]:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sx, dy + sy]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #     #for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sx, dy - sy]
        #         poly.append(pt)
        #
        # elif avg_trial.trial_translation in [&#34;a&#34;, &#34;e&#34;]:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sy, dy]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sy, dy]
        #         poly.append(pt)
        #
        # else:
        #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        #         pt = [dx + sy, dy + sx]
        #         poly.append(pt)
        #
        #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
        #         pt = [dx - sy, dy - sx]
        #         poly.append(pt)

        polyg = plt.Polygon(poly, color=color, alpha=0.4)
        plt.gca().add_patch(polyg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>asterisk_trial.AsteriskTrialData</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asterisk_test.asterisk_average.AveragedTrial.rotations"><code class="name">var <span class="ident">rotations</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asterisk_test.asterisk_average.AveragedTrial.avg_debug_plot"><code class="name flex">
<span>def <span class="ident">avg_debug_plot</span></span>(<span>self, show_plot=True, save_plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots one specific average together with all the data that was averaged for sanity checking the average.
:param show_plot: flag to show plot. Default is true
:param save_plot: flat to save plot as a file. Default is False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_debug_plot(self, show_plot=True, save_plot=False):
    &#34;&#34;&#34;
    Plots one specific average together with all the data that was averaged for sanity checking the average.
    :param show_plot: flag to show plot. Default is true
    :param save_plot: flat to save plot as a file. Default is False
    &#34;&#34;&#34;
    # TODO: show all target line points on plot, and show at least one averaging interval
    # plot the trials
    for i, t in enumerate(self.averaged_trials):
        # TODO: make it not use poses later
        plt.plot(t.poses[&#39;x&#39;], t.poses[&#39;y&#39;], label=f&#34;trial {i}&#34;, alpha=0.5, color=&#34;xkcd:blue grey&#34;)

    # plot average
    plt.plot(self.poses[&#39;x&#39;], self.poses[&#39;y&#39;], label=&#34;avg&#34;, color=&#34;xkcd:burnt orange&#34;)
    self.plot_sd(&#34;xkcd:burnt orange&#34;)

    if save_plot:
        plt.savefig(f&#34;pics/avgdebug_{self.subject}_{self.hand.get_name()}_{self.trial_translation}_&#34;
                    f&#34;{self.trial_rotation}_{self.trial_number}.jpg&#34;, format=&#39;jpg&#39;)
        # name -&gt; tuple: subj, hand  names
        print(&#34;Figure saved.&#34;)
        print(&#34; &#34;)

    if show_plot:
        plt.legend()
        plt.show()</code></pre>
</details>
</dd>
<dt id="asterisk_test.asterisk_average.AveragedTrial.get_poses_sd"><code class="name flex">
<span>def <span class="ident">get_poses_sd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Separates poses into x, y, theta for easy plotting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_poses_sd(self):
    &#34;&#34;&#34;
    Separates poses into x, y, theta for easy plotting.
    &#34;&#34;&#34;
    # get the poses
    x = self.pose_sd[&#34;x&#34;]
    y = self.pose_sd[&#34;y&#34;]
    twist = self.pose_sd[&#34;rmag&#34;]

    return_x = pd.Series.to_list(x.dropna())
    return_y = pd.Series.to_list(y.dropna())
    return_twist = pd.Series.to_list(twist.dropna())

    return return_x, return_y, return_twist</code></pre>
</details>
</dd>
<dt id="asterisk_test.asterisk_average.AveragedTrial.make_average_line"><code class="name flex">
<span>def <span class="ident">make_average_line</span></span>(<span>self, trials)</span>
</code></dt>
<dd>
<div class="desc"><p>Average the path of 2 or more AsteriskTrialObjects. Produces average and standard deviations.
Saves this data on the object itself.
:param trials: list of trials to average</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_average_line(self, trials):
    &#34;&#34;&#34;
    Average the path of 2 or more AsteriskTrialObjects. Produces average and standard deviations.
    Saves this data on the object itself.
    :param trials: list of trials to average
    &#34;&#34;&#34;

    # collect the asterisktrialdata objects
    self.names = []  # if rerunning an average with same object, make sure these lists are empty
    self.averaged_trials = []
    for t_n in trials:
        self.names.append(t_n.generate_name())
        self.averaged_trials.append(t_n)

    # first take attributes of first asterisktrialdata object and take its attributes
    trial = self.averaged_trials[0]
    self.subject = trial.subject  # TODO: add more subjects, make this a list? -&gt; will affect other func too
    self.trial_translation = trial.trial_translation
    self.trial_rotation = trial.trial_rotation
    self.trial_num = trial.trial_num
    self.target_line = trial.target_line

    # get all the data
    data_points = pd.DataFrame()  # makes an empty dataframe
    for t in self.averaged_trials:
        data_points = data_points.append(t.poses)

    # rotate the line so we can do everything based on the x axis
    r_target_x, r_target_y = AsteriskPlotting.get_c(100)
    rotated_target_line = np.column_stack((r_target_x, r_target_y))
    rotated_data = self._rotate_points(data_points, self.rotations[self.trial_translation])

    avg_line = pd.DataFrame()
    avg_std = pd.DataFrame()

    # now we go through averaging
    for t in rotated_target_line:
        t_x = t[0]
        points = self._get_points(rotated_data, t_x, 0.05)
        # TODO: 0.05 is arbitrary... make bounds scale with resolution of target_line?
        averaged_point = points.mean(axis=0)  # averages each column in DataFrame
        std_point = points.std(axis=0)
        avg_line = avg_line.append(averaged_point, ignore_index=True)
        avg_std = avg_std.append(std_point, ignore_index=True)

    # rotate everything back
    correct_avg = self._rotate_points(avg_line, -1 * self.rotations[self.trial_translation])
    correct_std = self._rotate_points(avg_std, -1 * self.rotations[self.trial_translation])

    self.poses = correct_avg
    self.pose_sd = correct_std  # TODO: std confidence intervals don&#39;t seem to match up well, need to investigate

    print(f&#34;Averaged: {self.subject}_{self.trial_translation}_{self.trial_rotation}&#34;)

    # now filter and run fd
    self.moving_average()
    # self.translation_fd, self.rotation_fd = self.calc_frechet_distance()  # TODO: broken for avg, investigate!

    return correct_avg</code></pre>
</details>
</dd>
<dt id="asterisk_test.asterisk_average.AveragedTrial.plot_sd"><code class="name flex">
<span>def <span class="ident">plot_sd</span></span>(<span>self, color, use_filtered=False)</span>
</code></dt>
<dd>
<div class="desc"><p>plot the standard deviations as a confidence interval around the averaged line
:param color: color for sd polygon, must be compatible with matplotlib.
:param use_filtered: enables option to use filtered or unfiltered data. Defaults to False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_sd(self, color, use_filtered=False):
    &#34;&#34;&#34;
    plot the standard deviations as a confidence interval around the averaged line
    :param color: color for sd polygon, must be compatible with matplotlib.
    :param use_filtered: enables option to use filtered or unfiltered data. Defaults to False
    &#34;&#34;&#34;
    data_x, data_y, data_t = self.get_poses(use_filtered)
    sd_x, sd_y, sd_t = self.get_poses_sd()

    # necessary for building the polygon
    r_x = list(reversed(data_x))
    r_y = list(reversed(data_y))
    r_sx = list(reversed(sd_x))
    r_sy = list(reversed(sd_y))

    poly = []
    for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
        pt = [dx + sx, dy + sy]
        poly.append(pt)

    for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
        pt = [dx - sx, dy - sy]
        poly.append(pt)

    # TODO: figure out correct setup later, it has something to do with the funky confidence intervals
    # if avg_trial.trial_translation in [&#34;c&#34;, &#34;g&#34;]:
    #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
    #         pt = [dx + sx, dy + sy]
    #         poly.append(pt)
    #
    #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
    #     #for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
    #         pt = [dx - sx, dy - sy]
    #         poly.append(pt)
    #
    # elif avg_trial.trial_translation in [&#34;a&#34;, &#34;e&#34;]:
    #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
    #         pt = [dx + sy, dy]
    #         poly.append(pt)
    #
    #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
    #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
    #         pt = [dx - sy, dy]
    #         poly.append(pt)
    #
    # else:
    #     for dx, dy, sx, sy in zip(data_x, data_y, sd_x, sd_y):
    #         pt = [dx + sy, dy + sx]
    #         poly.append(pt)
    #
    #     for dx, dy, sx, sy in zip(r_x, r_y, r_sx, r_sy):
    #         # for a, v in zip(reversed(asterisk_avg.pose_average), reversed(vec_offset)):
    #         pt = [dx - sy, dy - sx]
    #         poly.append(pt)

    polyg = plt.Polygon(poly, color=color, alpha=0.4)
    plt.gca().add_patch(polyg)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="asterisk_test" href="index.html">asterisk_test</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="asterisk_test.asterisk_average.AveragedTrial" href="#asterisk_test.asterisk_average.AveragedTrial">AveragedTrial</a></code></h4>
<ul class="">
<li><code><a title="asterisk_test.asterisk_average.AveragedTrial.avg_debug_plot" href="#asterisk_test.asterisk_average.AveragedTrial.avg_debug_plot">avg_debug_plot</a></code></li>
<li><code><a title="asterisk_test.asterisk_average.AveragedTrial.get_poses_sd" href="#asterisk_test.asterisk_average.AveragedTrial.get_poses_sd">get_poses_sd</a></code></li>
<li><code><a title="asterisk_test.asterisk_average.AveragedTrial.make_average_line" href="#asterisk_test.asterisk_average.AveragedTrial.make_average_line">make_average_line</a></code></li>
<li><code><a title="asterisk_test.asterisk_average.AveragedTrial.plot_sd" href="#asterisk_test.asterisk_average.AveragedTrial.plot_sd">plot_sd</a></code></li>
<li><code><a title="asterisk_test.asterisk_average.AveragedTrial.rotations" href="#asterisk_test.asterisk_average.AveragedTrial.rotations">rotations</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>