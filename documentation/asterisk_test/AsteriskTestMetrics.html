<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>asterisk_test.AsteriskTestMetrics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>asterisk_test.AsteriskTestMetrics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import numpy as np
from numpy import sin, cos, pi, linspace, sqrt, abs, arctan2, zeros, floor, nan
import csv
from pathlib import Path
import os

from AsteriskTestTypes import generate_fname, AsteriskTestTypes


class Pose2D:
    def __init__(self, in_x=0, in_y=0, in_theta=0):
        &#34;&#34;&#34; Pose in 2 dimensions
        :param in_x x location
        :param in_y y location
        :param in_theta rotation angle, in degrees&#34;&#34;&#34;

        self.x = in_x
        self.y = in_y
        self.theta = in_theta

    def distance(self, pose, scl_ratio=(0.5, 0.5)):
        &#34;&#34;&#34;Difference between self and another pose
        :type pose: Pose2D
        :param pose another Pose2D
        :param scl_ratio - how much to scale distance and rotation error by
        :returns a number&#34;&#34;&#34;

        # Standard euclidean distance, scaled by sin(45)
        dist_trans = sqrt((self.x - pose.x) ** 2 + (self.y - pose.y) ** 2) / sin(pi/4)
        # set up 20 deg of error as approximately 1 unit of translation error
        ang_rot = abs(self.theta - pose.theta)
        if ang_rot &gt; 180:
            ang_rot -= 180
        dist_rot = (ang_rot / 45.0)

        # return the average
        return scl_ratio[0] * dist_trans + scl_ratio[1] * dist_rot

    def lin_interp(self, pose, t):
        &#34;&#34;&#34; linearly interpolate the pose values
        :param pose pose to interpoloate to Pose2D
        :param t a number between 0 and 1
        :return the interpolated pose Pose2D&#34;&#34;&#34;
        return Pose2D(self.x + t * pose.x, self.y + t * pose.y, self.theta + t * pose.theta)

    def __str__(self):
        return &#34;x : {0:.2f}, y : {1:.2f}, theta : {2}&#34;.format(self.x, self.y, self.theta)


class AsteriskTestResults(AsteriskTestTypes):
    status_values = {&#34;Successful&#34;, &#34;Unsuccessful&#34;, &#34;Not_tried&#34;}
    def __init__(self, name, in_obj_poses: np.array, in_target_path: [Pose2D]):
        &#34;&#34;&#34;distances, angles, index in test
        :param name - trial file name&#34;&#34;&#34;
        self.test_name = name

        # Actual distances
        self.dist_target = nan
        self.dist_frechet = nan
        self.dist_along_translation = nan
        self.dist_along_rotation = nan

        # Data for Frechet distance
        self.end_target_index = -1
        self.target_indices = []

        # Save data
        self.obj_poses = in_obj_poses.copy()  # Copy because re-written each time
        self.target_path = in_target_path # These should be stable

    def __str__(self):
        &#34;&#34;&#34;Print results&#34;&#34;&#34;
        ret_str = super().__str__()
        if self.end_target_index == -1:
            ret_str = ret_str + &#34;, no result&#34;
        if self.dist_target is not nan:
            ret_str = ret_str + &#34; Target: {0:0.3f}&#34;.format(self.dist_target)
        if self.dist_along_translation is not nan:
            ret_str = ret_str + &#34; D Trans: {0:0.3f}&#34;.format(self.dist_along_translation)
        if self.dist_along_rotation is not nan:
            ret_str = ret_str + &#34; D Rot: {0:0.3f}&#34;.format(self.dist_along_rotation)
        if self.dist_frechet is not nan:
            ret_str = ret_str + &#34; D Frec: {0:0.3f}&#34;.format(self.dist_frechet)
        return ret_str

    @staticmethod
    def write_header_data(f):
        &#34;&#34;&#34; Header row for csv file &#34;&#34;&#34;
        col_names = [&#34;Name&#34;, &#34;Type&#34;, &#34;TranslationName&#34;, &#34;RotationName&#34;, &#34;TwistName&#34;]
        col_names.extend([&#34;DistToTarget&#34;, &#34;DistAlongTranslation&#34;, &#34;DistAlongRotation&#34;, &#34;FrechetDistance&#34;])
        col_names.extend([&#34;LastIndex&#34;, &#34;Indices&#34;])
        f.writerow(col_names)

    def write_data(self, f):
        &#34;&#34;&#34; Write out data to a csv file
        :param f - csv file writer&#34;&#34;&#34;

        row_data = []
        row_data.append(self.test_name)
        row_data.append(self.get_test_name())
        row_data.append(self.get_translation_name())
        row_data.append(self.get_rotation_name())
        row_data.append(self.get_twist_name())
        row_data.append(self.dist_target)
        row_data.append(self.dist_along_translation)
        row_data.append(self.dist_along_rotation)
        row_data.append(self.dist_frechet)
        row_data.append(self.end_target_index)
        for i in self.target_indices:
            row_data.append(f&#34;{i}&#34;)

        f.writerow(row_data)


class AsteriskTestMetrics2D:
    metric_names = {&#34;Distance_along, Distance_target, Frechet_distance&#34;}
    translation_angles = linspace(90, 90-360, 8, endpoint=False)

    def __init__(self, n_samples=15):
        &#34;&#34;&#34;
        :param n_samples number of samples in target path&#34;&#34;&#34;
        self.target_paths = {}
        self.test_results = []
        self._add_target_paths(n_samples)
        self.reset_test_results()
        self.test_name = &#34;&#34;

    def reset_test_results(self):
        &#34;&#34;&#34;Zero out the results&#34;&#34;&#34;

        self.test_results = []

    def _add_target_paths(self, n_samples):
        &#34;&#34;&#34;Create ideal paths for each movement type
        :param n_samples number of samples to use on path&#34;&#34;&#34;

        target_translation_paths = []
        target_rotation_translation_paths = [[], []]
        divs = linspace(0, 1, n_samples, endpoint=True)
        for i, a in enumerate(self.translation_angles):
            x = cos(pi * a / 180)
            y = sin(pi * a / 180)
            target_translation_paths.append([])
            target_rotation_translation_paths[0].append([])
            target_rotation_translation_paths[1].append([])
            for d in divs:
                target_translation_paths[-1].append(Pose2D(x * d, y * d, 0))
                target_rotation_translation_paths[0][-1].append(Pose2D(x * d, y * d, AsteriskTestTypes.twist_directions[&#34;Clockwise&#34;]))
                target_rotation_translation_paths[1][-1].append(Pose2D(x * d, y * d, AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;]))

        target_rotation_paths = [[], []]
        for d in divs:
            target_rotation_paths[0].append(Pose2D(0, 0, d * AsteriskTestTypes.rotation_directions[&#34;Clockwise&#34;]))
            target_rotation_paths[1].append(Pose2D(0, 0, d * AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;]))

        self.target_paths[&#34;Translation&#34;] = target_translation_paths
        self.target_paths[&#34;Rotation&#34;] = target_rotation_paths
        self.target_paths[&#34;Twist_translation&#34;] = target_rotation_translation_paths

    @staticmethod
    def _narrow_target(obj_pose, target_poses, scl_ratio=(0.5, 0.5)) -&gt; int:
        &#34;&#34;&#34; narrown down the closest point on the target poses
        :param obj_pose last object pose Pose2D
        :param target_poses [Pose2D;
        :param scl_ratio - how much to scale distance and rotation error by
        :returns target_i the index of the best match &#34;&#34;&#34;

        dists_targets = [obj_pose.distance(p, scl_ratio) for p in target_poses]
        i_target = dists_targets.index(min(dists_targets))

        return i_target

    @staticmethod
    def _frechet_dist(poses_obj, i_target, target_poses, scl_ratio=(0.5, 0.5)) -&gt;(int, float):
        &#34;&#34;&#34; Implement Frechet distance
        :param poses_obj all the object poses np.array
        :param i_target the closest point in target_poses
        :param target_poses [Pose2D];
        :param scl_ratio - how much to scale distance and rotation error by
        :returns max of the min distance between target_poses and obj_poses &#34;&#34;&#34;
        # https://towardsdatascience.com/fast-discrete-fr%C3%A9chet-distance-d6b422a8fb77

        # Length of target curve
        n_target = min(i_target+1, len(target_poses))
        # Length of object path
        n_object_path = poses_obj.shape[1]

        # Matrix to store data in as we calculate Frechet distance
        # Entry i,j has the cost of pairing i with j, assuming best pairings up to that point
        ca = np.zeros((n_target, n_object_path), dtype=np.float64)
        ds = np.zeros((n_target, n_object_path), dtype=np.float64)
        dsum = np.zeros((n_target, n_object_path), dtype=np.float64)
        imatch = np.zeros((n_target, n_object_path), dtype=np.int)

        print(&#34;Frechet debug: target {0}, n {1}&#34;.format(i_target, n_object_path))

        # Top left corner
        ca[0, 0] = target_poses[0].distance(Pose2D(poses_obj[0, 0], poses_obj[1, 0], poses_obj[2, 0]), scl_ratio)
        ds[0, 0] = ca[0, 0]
        dsum[0, 0] = ds[0, 0]
        imatch[0, 0] = 0  # Match the first target pose to the first object pose
        target_index = [i for i in range(0, n_target)]

        # Fill in left column ...
        for i_t in range(1, n_target):
            ds[i_t, 0] = target_poses[i_t].distance(Pose2D(poses_obj[0, 0], poses_obj[1, 0], poses_obj[2, 0]), scl_ratio)
            ca[i_t, 0] = max(ca[i_t-1, 0], ds[i_t, 0])
            dsum[i_t, 0] = dsum[i_t - 1, 0] + ds[i_t, 0]
            imatch[i_t, 0] = 0  # Match the ith target pose to the first object pose

        # ... and top row
        for i_p in range(1, n_object_path):
            ds[0, i_p] = target_poses[0].distance(Pose2D(poses_obj[0, i_p], poses_obj[1, i_p], poses_obj[2, i_p]), scl_ratio)
            ca[0, i_p] = max(ca[0, i_p - 1], ds[0, i_p])
            if ds[0, i_p] &lt; dsum[0, i_p - 1]:
                imatch[0, i_p] = i_p  # Match the first target pose to this object pose
                dsum[0, i_p] = ds[0, i_p]
            else:
                imatch[0, i_p] = imatch[0, i_p-1] # Match to an earlier pose
                dsum[0, i_p] = dsum[0, i_p-1]

        # Remaining matrix
        for i_t in range(1, n_target):
            tp = target_poses[i_t]
            for i_p in range(1, n_object_path):
                ds[i_t, i_p] = tp.distance(Pose2D(poses_obj[0, i_p], poses_obj[1, i_p], poses_obj[2, i_p]), scl_ratio)
                ca[i_t, i_p] = max(min(ca[i_t - 1, i_p],
                                       ca[i_t - 1, i_p - 1],
                                       ca[i_t, i_p - 1]),
                                   ds[i_t, i_p])
                # Compare using this match with the best match upper row so far
                # to best match found so far
                if ds[i_t, i_p] + dsum[i_t-1, i_p] &lt; dsum[i_t, i_p-1]:
                    imatch[i_t, i_p] = i_p
                    dsum[i_t, i_p] = ds[i_t, i_p] + dsum[i_t-1, i_p]
                else:
                    dsum[i_t, i_p] = dsum[i_t, i_p-1]    # Keep the old match
                    imatch[i_t, i_p] = imatch[i_t, i_p-1]

        # initialize with minimum value match - allows backtracking
        target_index = []
        v_min = np.amin(ds, axis=1)
        for r in range(0, n_target):
            indx = np.where(ds[r, :] == v_min[r])
            target_index.append(indx[0][0])

        b_is_ok = True
        for i in range(0, n_target-1):
            if target_index[i+1] &lt; target_index[i]:
                b_is_ok = False
                print(&#34;Frechet: Found array not sorted&#34;)

        # Could just do this, but leaving be for a moment to ensure working
        if b_is_ok == False:
            for i_t in range(0, n_target):
                target_index[i_t] = imatch[i_t, n_object_path-1]

        return ca[n_target-1, n_object_path-1], target_index

    def add_translation_test(self, name, in_which, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param name: str - name of test, eg, hand type
        :param in_which is 0..7, which angle in the asterisk
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Translation&#34;][in_which]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_translation_test(in_which)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        n_total = poses_obj.shape[1]
        last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
        expected_angle = self.translation_angles[in_which]
        if last_pose_angle - expected_angle &gt; 180:
            last_pose_angle -= 360
        elif expected_angle - last_pose_angle &gt; 180:
            last_pose_angle += 360

        if abs(last_pose_angle - expected_angle) &gt; 65:
            print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which, last_pose_angle,
                                                                                          self.translation_angles[
                                                                                              in_which]))

        # Use mostly translation for distance
        scl_ratio = (1- 0.01, 0.01)
        ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose, scl_ratio)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)
        self.test_results.append(ret_dists)
        return ret_dists

    def add_rotation_test(self, name, in_which, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param in_which is Clockwise or Counterclockwise
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Rotation&#34;][in_which]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_rotation_test(in_which)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        dist_from_center = sqrt(last_pose_obj.x**2 + last_pose_obj.y**2)
        if dist_from_center &gt; 0.2:
            print(&#34;Warning: rotation test {} had big offset {}&#34;.format(in_which, dist_from_center))

        # Use mostly rotation error for distance
        scl_ratio = (0.01, 1 - 0.01)

        # Calculate distances
        ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;]
        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)

        self.test_results.append(ret_dists)
        return ret_dists

    def add_twist_translation_test(self, name, in_which_rot, in_which_trans, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param in_which_rot is 0 or 1, clockwise or counter
        :param in_which_trans is 0..7, which angle in the asterisk
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Twist_translation&#34;][in_which_rot][in_which_trans]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_twist_translation_test(in_which_trans, in_which_rot)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        n_total = poses_obj.shape[1]

        last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
        expected_angle = self.translation_angles[in_which_trans]
        if last_pose_angle - expected_angle &gt; 180:
            last_pose_angle -= 360
        elif expected_angle - last_pose_angle &gt; 180:
            last_pose_angle += 360

        if abs(last_pose_angle - expected_angle) &gt; 65:
            print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which_trans, last_pose_angle,
                                                                                          self.translation_angles[
                                                                                              in_which_trans]))

        # Use mostly translation for distance
        scl_ratio = (1 - 0.01, 0.01)

        ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
        ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;]

        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)
        ret_dists.target_paths = self.target_paths

        self.test_results.append(ret_dists)
        return ret_dists

    def get_test_results(self, att: AsteriskTestTypes)-&gt;[AsteriskTestResults]:
        &#34;&#34;&#34;Get all the tests of that type
        :param att Asterisk test type
        :returns [AsteriskTestResults] &#34;&#34;&#34;

        return [res for res in self.test_results if res.is_type(att)]

    def write_test_results(self, fname):
        &#34;&#34;&#34; Write the test results out to a csv file
        :param fname: str
        :rtype none&#34;&#34;&#34;
        with open(fname, &#34;w&#34;) as f:
            csv_f = csv.writer(f, delimiter=&#39;,&#39;)
            AsteriskTestResults.write_header_data(csv_f)
            for t in self.test_results:
                t.write_data(csv_f)

    def test_translation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None
        &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 100
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, (8, n_poses))
        noise_y = uniform(-0.1, 0.1, (8, n_poses))
        noise_ang = uniform(-5, 5, (8, n_poses))

        print(&#34;Testing translations&#34;)
        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = noise_ang[i_ang, i_p]

            dists = self.add_translation_test(&#34;Test&#34;, i_ang, obj_poses)
            print(&#34;Translation, angle {0}: {1}&#34;.format(ang, dists))

    def test_rotation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 50
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, n_poses)
        noise_y = uniform(-0.1, 0.1, n_poses)
        noise_ang = uniform(-0.5, 0.5, n_poses)

        for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Clockwise&#34;], n_poses)):
            obj_poses[0, i_ang] = noise_x[i_ang]
            obj_poses[1, i_ang] = noise_y[i_ang]
            obj_poses[2, i_ang] = ang + noise_ang[i_ang]

        dists = self.add_rotation_test(&#34;Test&#34;, 0, obj_poses)
        print(&#34;Rotation, angle {0}, distances {1}&#34;.format(&#34;Clockwise&#34;, dists))
        for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;], n_poses)):
            obj_poses[2, i_ang] = ang + noise_ang[i_ang]
        dists = self.add_rotation_test(&#34;Test&#34;, 1, obj_poses)
        print(&#34;Rotation, angle {0}: {1}&#34;.format(&#34;Counterclockwise&#34;, dists))

    def test_twist_translation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 100
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, (8, n_poses))
        noise_y = uniform(-0.1, 0.1, (8, n_poses))
        noise_ang = uniform(-5, 5, (8, n_poses))

        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Clockwise&#34;] + noise_ang[i_ang, i_p]

            dists = self.add_twist_translation_test(&#34;Test&#34;, 0, i_ang, obj_poses)
            print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Clockwise&#34;, ang, dists))

        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;] + noise_ang[i_ang, i_p]

            dists = self.add_twist_translation_test(&#34;Test&#34;, 1, i_ang, obj_poses)
            print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Counterclockwise&#34;, ang, dists))

    @staticmethod
    def run_tests():
        my_asterisk_tests = AsteriskTestMetrics2D()

        my_asterisk_tests.test_translation()
        my_asterisk_tests.test_rotation()
        my_asterisk_tests.test_twist_translation()

        my_asterisk_tests.write_test_results(&#34;test_results.csv&#34;)

    def process_file(self, name: str, trial_type: str, ang_name: str, obj_poses):
        &#34;&#34;&#34;Read the files, compute the metrics
        :param name subject + hand + trial name
        :param trial_type from asterisk_0_prompts, minus, plus, etc
        :param ang_name from asterisk_0_prompts, none or a, b, c etc
        :param obj_poses object poses
        :returns Distances&#34;&#34;&#34;

        trial_direction = ord(trial_type[0]) - ord(&#39;a&#39;)
        if ang_name == &#34;m15&#34;:
            dists = self.add_twist_translation_test(name, 1, trial_direction, obj_poses)

        elif ang_name == &#34;p15&#34;:
            dists = self.add_twist_translation_test(name, 0, trial_direction, obj_poses)

        elif ang_name == &#34;cw&#34;:
            dists = self.add_rotation_test(name, 1, obj_poses)

        elif ang_name == &#34;ccw&#34;:
            dists = self.add_rotation_test(name, 0, obj_poses)

        else:
            dists = self.add_translation_test(name, trial_direction, obj_poses)

        return dists

    @staticmethod
    def process_files(subject_name, hand):
        &#34;&#34;&#34;Read the files, compute the metrics
        # !param dir_name input file name
        :param subject_name name of subject to process
        :param hand name of hand to process
        :return my_tests Array of AsteriskTestMetrics with tests&#34;&#34;&#34;

        my_tests = []
        for fname in generate_fname(subject_name, hand):
            _, subject, hand, translation, rotation, end = fname.split(&#34;_&#34;)
            number, _ = end.split(&#34;.&#34;)

            try:
                with open(fname, &#34;r&#34;) as csvfile:
                    csv_file = csv.reader(csvfile, delimiter=&#39;,&#39;)
                    obj_poses = []
                    for i, row in enumerate(csv_file):
                        try:
                            obj_poses.append([float(row[1]), float(row[2]), float(row[3])])
                        except:
                            pass

                    obj_poses = np.transpose(np.array(obj_poses))
                    print(f&#34;{fname}\n x {obj_poses[0,-1]} y {obj_poses[1, -1]} t {obj_poses[2, -1]}&#34;)

                    hand_name = hand
                    trial_translation = translation
                    trial_rotation = rotation
                    trial_number = int(number)-1
                    name = f&#34;{subject_name}_{hand_name}_Trial{trial_number}&#34;

                    while len(my_tests) &lt;= trial_number:
                        my_tests.append(AsteriskTestMetrics2D())

                    my_tests[trial_number].test_name = f&#34;{subject_name}_{hand_name}&#34;
                    dists = my_tests[trial_number].process_file(name, trial_translation, trial_rotation, obj_poses)

                    print(f&#34;{dists}\n&#34;)
            except FileNotFoundError:
                print(f&#34;File not found: {fname}&#34;)

        return my_tests

if __name__ == &#39;__main__&#39;:
    #AsteriskTestMetrics2D.run_tests()

    subjects = [&#34;sub1&#34;, &#34;sub2&#34;]
    hand_names = [&#34;basic&#34;, &#34;m2stiff&#34;, &#34;m2active&#34;, &#34;2v2&#34;, &#34;3v3&#34;, &#34;2v3&#34;, &#34;barrett&#34;, &#34;modelvf&#34;]

    home_directory = Path(__file__).parent.absolute()
    file_dir = &#34;filtered/&#34;

    for h in hand_names:
        for s in subjects:
            os.chdir(file_dir)
            subject_name_process = f&#34;f15_{s}&#34;
            hand_process = h
            my_test_results = AsteriskTestMetrics2D.process_files(subject_name_process, hand_process)

            os.chdir(home_directory)

            try:
                for i, t in enumerate(my_test_results):
                    t.write_test_results(f&#34;check_res_{t.test_name}_{i}.csv&#34;)
            except Exception as e:
                print(f&#34;{t.test_name}, {e}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D"><code class="flex name class">
<span>class <span class="ident">AsteriskTestMetrics2D</span></span>
<span>(</span><span>n_samples=15)</span>
</code></dt>
<dd>
<div class="desc"><p>:param n_samples number of samples in target path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsteriskTestMetrics2D:
    metric_names = {&#34;Distance_along, Distance_target, Frechet_distance&#34;}
    translation_angles = linspace(90, 90-360, 8, endpoint=False)

    def __init__(self, n_samples=15):
        &#34;&#34;&#34;
        :param n_samples number of samples in target path&#34;&#34;&#34;
        self.target_paths = {}
        self.test_results = []
        self._add_target_paths(n_samples)
        self.reset_test_results()
        self.test_name = &#34;&#34;

    def reset_test_results(self):
        &#34;&#34;&#34;Zero out the results&#34;&#34;&#34;

        self.test_results = []

    def _add_target_paths(self, n_samples):
        &#34;&#34;&#34;Create ideal paths for each movement type
        :param n_samples number of samples to use on path&#34;&#34;&#34;

        target_translation_paths = []
        target_rotation_translation_paths = [[], []]
        divs = linspace(0, 1, n_samples, endpoint=True)
        for i, a in enumerate(self.translation_angles):
            x = cos(pi * a / 180)
            y = sin(pi * a / 180)
            target_translation_paths.append([])
            target_rotation_translation_paths[0].append([])
            target_rotation_translation_paths[1].append([])
            for d in divs:
                target_translation_paths[-1].append(Pose2D(x * d, y * d, 0))
                target_rotation_translation_paths[0][-1].append(Pose2D(x * d, y * d, AsteriskTestTypes.twist_directions[&#34;Clockwise&#34;]))
                target_rotation_translation_paths[1][-1].append(Pose2D(x * d, y * d, AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;]))

        target_rotation_paths = [[], []]
        for d in divs:
            target_rotation_paths[0].append(Pose2D(0, 0, d * AsteriskTestTypes.rotation_directions[&#34;Clockwise&#34;]))
            target_rotation_paths[1].append(Pose2D(0, 0, d * AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;]))

        self.target_paths[&#34;Translation&#34;] = target_translation_paths
        self.target_paths[&#34;Rotation&#34;] = target_rotation_paths
        self.target_paths[&#34;Twist_translation&#34;] = target_rotation_translation_paths

    @staticmethod
    def _narrow_target(obj_pose, target_poses, scl_ratio=(0.5, 0.5)) -&gt; int:
        &#34;&#34;&#34; narrown down the closest point on the target poses
        :param obj_pose last object pose Pose2D
        :param target_poses [Pose2D;
        :param scl_ratio - how much to scale distance and rotation error by
        :returns target_i the index of the best match &#34;&#34;&#34;

        dists_targets = [obj_pose.distance(p, scl_ratio) for p in target_poses]
        i_target = dists_targets.index(min(dists_targets))

        return i_target

    @staticmethod
    def _frechet_dist(poses_obj, i_target, target_poses, scl_ratio=(0.5, 0.5)) -&gt;(int, float):
        &#34;&#34;&#34; Implement Frechet distance
        :param poses_obj all the object poses np.array
        :param i_target the closest point in target_poses
        :param target_poses [Pose2D];
        :param scl_ratio - how much to scale distance and rotation error by
        :returns max of the min distance between target_poses and obj_poses &#34;&#34;&#34;
        # https://towardsdatascience.com/fast-discrete-fr%C3%A9chet-distance-d6b422a8fb77

        # Length of target curve
        n_target = min(i_target+1, len(target_poses))
        # Length of object path
        n_object_path = poses_obj.shape[1]

        # Matrix to store data in as we calculate Frechet distance
        # Entry i,j has the cost of pairing i with j, assuming best pairings up to that point
        ca = np.zeros((n_target, n_object_path), dtype=np.float64)
        ds = np.zeros((n_target, n_object_path), dtype=np.float64)
        dsum = np.zeros((n_target, n_object_path), dtype=np.float64)
        imatch = np.zeros((n_target, n_object_path), dtype=np.int)

        print(&#34;Frechet debug: target {0}, n {1}&#34;.format(i_target, n_object_path))

        # Top left corner
        ca[0, 0] = target_poses[0].distance(Pose2D(poses_obj[0, 0], poses_obj[1, 0], poses_obj[2, 0]), scl_ratio)
        ds[0, 0] = ca[0, 0]
        dsum[0, 0] = ds[0, 0]
        imatch[0, 0] = 0  # Match the first target pose to the first object pose
        target_index = [i for i in range(0, n_target)]

        # Fill in left column ...
        for i_t in range(1, n_target):
            ds[i_t, 0] = target_poses[i_t].distance(Pose2D(poses_obj[0, 0], poses_obj[1, 0], poses_obj[2, 0]), scl_ratio)
            ca[i_t, 0] = max(ca[i_t-1, 0], ds[i_t, 0])
            dsum[i_t, 0] = dsum[i_t - 1, 0] + ds[i_t, 0]
            imatch[i_t, 0] = 0  # Match the ith target pose to the first object pose

        # ... and top row
        for i_p in range(1, n_object_path):
            ds[0, i_p] = target_poses[0].distance(Pose2D(poses_obj[0, i_p], poses_obj[1, i_p], poses_obj[2, i_p]), scl_ratio)
            ca[0, i_p] = max(ca[0, i_p - 1], ds[0, i_p])
            if ds[0, i_p] &lt; dsum[0, i_p - 1]:
                imatch[0, i_p] = i_p  # Match the first target pose to this object pose
                dsum[0, i_p] = ds[0, i_p]
            else:
                imatch[0, i_p] = imatch[0, i_p-1] # Match to an earlier pose
                dsum[0, i_p] = dsum[0, i_p-1]

        # Remaining matrix
        for i_t in range(1, n_target):
            tp = target_poses[i_t]
            for i_p in range(1, n_object_path):
                ds[i_t, i_p] = tp.distance(Pose2D(poses_obj[0, i_p], poses_obj[1, i_p], poses_obj[2, i_p]), scl_ratio)
                ca[i_t, i_p] = max(min(ca[i_t - 1, i_p],
                                       ca[i_t - 1, i_p - 1],
                                       ca[i_t, i_p - 1]),
                                   ds[i_t, i_p])
                # Compare using this match with the best match upper row so far
                # to best match found so far
                if ds[i_t, i_p] + dsum[i_t-1, i_p] &lt; dsum[i_t, i_p-1]:
                    imatch[i_t, i_p] = i_p
                    dsum[i_t, i_p] = ds[i_t, i_p] + dsum[i_t-1, i_p]
                else:
                    dsum[i_t, i_p] = dsum[i_t, i_p-1]    # Keep the old match
                    imatch[i_t, i_p] = imatch[i_t, i_p-1]

        # initialize with minimum value match - allows backtracking
        target_index = []
        v_min = np.amin(ds, axis=1)
        for r in range(0, n_target):
            indx = np.where(ds[r, :] == v_min[r])
            target_index.append(indx[0][0])

        b_is_ok = True
        for i in range(0, n_target-1):
            if target_index[i+1] &lt; target_index[i]:
                b_is_ok = False
                print(&#34;Frechet: Found array not sorted&#34;)

        # Could just do this, but leaving be for a moment to ensure working
        if b_is_ok == False:
            for i_t in range(0, n_target):
                target_index[i_t] = imatch[i_t, n_object_path-1]

        return ca[n_target-1, n_object_path-1], target_index

    def add_translation_test(self, name, in_which, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param name: str - name of test, eg, hand type
        :param in_which is 0..7, which angle in the asterisk
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Translation&#34;][in_which]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_translation_test(in_which)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        n_total = poses_obj.shape[1]
        last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
        expected_angle = self.translation_angles[in_which]
        if last_pose_angle - expected_angle &gt; 180:
            last_pose_angle -= 360
        elif expected_angle - last_pose_angle &gt; 180:
            last_pose_angle += 360

        if abs(last_pose_angle - expected_angle) &gt; 65:
            print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which, last_pose_angle,
                                                                                          self.translation_angles[
                                                                                              in_which]))

        # Use mostly translation for distance
        scl_ratio = (1- 0.01, 0.01)
        ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose, scl_ratio)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)
        self.test_results.append(ret_dists)
        return ret_dists

    def add_rotation_test(self, name, in_which, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param in_which is Clockwise or Counterclockwise
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Rotation&#34;][in_which]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_rotation_test(in_which)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        dist_from_center = sqrt(last_pose_obj.x**2 + last_pose_obj.y**2)
        if dist_from_center &gt; 0.2:
            print(&#34;Warning: rotation test {} had big offset {}&#34;.format(in_which, dist_from_center))

        # Use mostly rotation error for distance
        scl_ratio = (0.01, 1 - 0.01)

        # Calculate distances
        ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;]
        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)

        self.test_results.append(ret_dists)
        return ret_dists

    def add_twist_translation_test(self, name, in_which_rot, in_which_trans, poses_obj):
        &#34;&#34;&#34;Add the translation test
        :param in_which_rot is 0 or 1, clockwise or counter
        :param in_which_trans is 0..7, which angle in the asterisk
        :param poses_obj is a 3xn matrix of x,y,theta poses
        :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

        target_path = self.target_paths[&#34;Twist_translation&#34;][in_which_rot][in_which_trans]
        target_pose = target_path[-1]

        # Setup test results
        ret_dists = AsteriskTestResults(name, poses_obj, target_path)
        ret_dists.set_twist_translation_test(in_which_trans, in_which_rot)

        # Check that we&#39;re in at least roughly the right ballpark for the end pose
        last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
        n_total = poses_obj.shape[1]

        last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
        expected_angle = self.translation_angles[in_which_trans]
        if last_pose_angle - expected_angle &gt; 180:
            last_pose_angle -= 360
        elif expected_angle - last_pose_angle &gt; 180:
            last_pose_angle += 360

        if abs(last_pose_angle - expected_angle) &gt; 65:
            print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which_trans, last_pose_angle,
                                                                                          self.translation_angles[
                                                                                              in_which_trans]))

        # Use mostly translation for distance
        scl_ratio = (1 - 0.01, 0.01)

        ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
        ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;]

        ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

        ret_dists.dist_target = last_pose_obj.distance(target_pose)

        if ret_dists.end_target_index == 0:
            print(&#34;Warning: Closest pose was first pose&#34;)
            ret_dists.end_target_index += 1

        ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                              ret_dists.end_target_index,
                                                                              target_path,
                                                                              scl_ratio)
        ret_dists.target_paths = self.target_paths

        self.test_results.append(ret_dists)
        return ret_dists

    def get_test_results(self, att: AsteriskTestTypes)-&gt;[AsteriskTestResults]:
        &#34;&#34;&#34;Get all the tests of that type
        :param att Asterisk test type
        :returns [AsteriskTestResults] &#34;&#34;&#34;

        return [res for res in self.test_results if res.is_type(att)]

    def write_test_results(self, fname):
        &#34;&#34;&#34; Write the test results out to a csv file
        :param fname: str
        :rtype none&#34;&#34;&#34;
        with open(fname, &#34;w&#34;) as f:
            csv_f = csv.writer(f, delimiter=&#39;,&#39;)
            AsteriskTestResults.write_header_data(csv_f)
            for t in self.test_results:
                t.write_data(csv_f)

    def test_translation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None
        &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 100
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, (8, n_poses))
        noise_y = uniform(-0.1, 0.1, (8, n_poses))
        noise_ang = uniform(-5, 5, (8, n_poses))

        print(&#34;Testing translations&#34;)
        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = noise_ang[i_ang, i_p]

            dists = self.add_translation_test(&#34;Test&#34;, i_ang, obj_poses)
            print(&#34;Translation, angle {0}: {1}&#34;.format(ang, dists))

    def test_rotation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 50
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, n_poses)
        noise_y = uniform(-0.1, 0.1, n_poses)
        noise_ang = uniform(-0.5, 0.5, n_poses)

        for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Clockwise&#34;], n_poses)):
            obj_poses[0, i_ang] = noise_x[i_ang]
            obj_poses[1, i_ang] = noise_y[i_ang]
            obj_poses[2, i_ang] = ang + noise_ang[i_ang]

        dists = self.add_rotation_test(&#34;Test&#34;, 0, obj_poses)
        print(&#34;Rotation, angle {0}, distances {1}&#34;.format(&#34;Clockwise&#34;, dists))
        for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;], n_poses)):
            obj_poses[2, i_ang] = ang + noise_ang[i_ang]
        dists = self.add_rotation_test(&#34;Test&#34;, 1, obj_poses)
        print(&#34;Rotation, angle {0}: {1}&#34;.format(&#34;Counterclockwise&#34;, dists))

    def test_twist_translation(self):
        &#34;&#34;&#34; Make fake translation data and add it
        :rtype: None &#34;&#34;&#34;
        from numpy.random import uniform

        n_poses = 100
        obj_poses = zeros([3, n_poses])
        noise_x = uniform(-0.1, 0.1, (8, n_poses))
        noise_y = uniform(-0.1, 0.1, (8, n_poses))
        noise_ang = uniform(-5, 5, (8, n_poses))

        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Clockwise&#34;] + noise_ang[i_ang, i_p]

            dists = self.add_twist_translation_test(&#34;Test&#34;, 0, i_ang, obj_poses)
            print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Clockwise&#34;, ang, dists))

        for i_ang, ang in enumerate(self.translation_angles):
            for i_p, div in enumerate(linspace(0, 1, n_poses)):
                obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
                obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
                obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;] + noise_ang[i_ang, i_p]

            dists = self.add_twist_translation_test(&#34;Test&#34;, 1, i_ang, obj_poses)
            print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Counterclockwise&#34;, ang, dists))

    @staticmethod
    def run_tests():
        my_asterisk_tests = AsteriskTestMetrics2D()

        my_asterisk_tests.test_translation()
        my_asterisk_tests.test_rotation()
        my_asterisk_tests.test_twist_translation()

        my_asterisk_tests.write_test_results(&#34;test_results.csv&#34;)

    def process_file(self, name: str, trial_type: str, ang_name: str, obj_poses):
        &#34;&#34;&#34;Read the files, compute the metrics
        :param name subject + hand + trial name
        :param trial_type from asterisk_0_prompts, minus, plus, etc
        :param ang_name from asterisk_0_prompts, none or a, b, c etc
        :param obj_poses object poses
        :returns Distances&#34;&#34;&#34;

        trial_direction = ord(trial_type[0]) - ord(&#39;a&#39;)
        if ang_name == &#34;m15&#34;:
            dists = self.add_twist_translation_test(name, 1, trial_direction, obj_poses)

        elif ang_name == &#34;p15&#34;:
            dists = self.add_twist_translation_test(name, 0, trial_direction, obj_poses)

        elif ang_name == &#34;cw&#34;:
            dists = self.add_rotation_test(name, 1, obj_poses)

        elif ang_name == &#34;ccw&#34;:
            dists = self.add_rotation_test(name, 0, obj_poses)

        else:
            dists = self.add_translation_test(name, trial_direction, obj_poses)

        return dists

    @staticmethod
    def process_files(subject_name, hand):
        &#34;&#34;&#34;Read the files, compute the metrics
        # !param dir_name input file name
        :param subject_name name of subject to process
        :param hand name of hand to process
        :return my_tests Array of AsteriskTestMetrics with tests&#34;&#34;&#34;

        my_tests = []
        for fname in generate_fname(subject_name, hand):
            _, subject, hand, translation, rotation, end = fname.split(&#34;_&#34;)
            number, _ = end.split(&#34;.&#34;)

            try:
                with open(fname, &#34;r&#34;) as csvfile:
                    csv_file = csv.reader(csvfile, delimiter=&#39;,&#39;)
                    obj_poses = []
                    for i, row in enumerate(csv_file):
                        try:
                            obj_poses.append([float(row[1]), float(row[2]), float(row[3])])
                        except:
                            pass

                    obj_poses = np.transpose(np.array(obj_poses))
                    print(f&#34;{fname}\n x {obj_poses[0,-1]} y {obj_poses[1, -1]} t {obj_poses[2, -1]}&#34;)

                    hand_name = hand
                    trial_translation = translation
                    trial_rotation = rotation
                    trial_number = int(number)-1
                    name = f&#34;{subject_name}_{hand_name}_Trial{trial_number}&#34;

                    while len(my_tests) &lt;= trial_number:
                        my_tests.append(AsteriskTestMetrics2D())

                    my_tests[trial_number].test_name = f&#34;{subject_name}_{hand_name}&#34;
                    dists = my_tests[trial_number].process_file(name, trial_translation, trial_rotation, obj_poses)

                    print(f&#34;{dists}\n&#34;)
            except FileNotFoundError:
                print(f&#34;File not found: {fname}&#34;)

        return my_tests</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.metric_names"><code class="name">var <span class="ident">metric_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.translation_angles"><code class="name">var <span class="ident">translation_angles</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_files"><code class="name flex">
<span>def <span class="ident">process_files</span></span>(<span>subject_name, hand)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the files, compute the metrics</p>
<h1 id="param-dir_name-input-file-name">!param dir_name input file name</h1>
<p>:param subject_name name of subject to process
:param hand name of hand to process
:return my_tests Array of AsteriskTestMetrics with tests</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_files(subject_name, hand):
    &#34;&#34;&#34;Read the files, compute the metrics
    # !param dir_name input file name
    :param subject_name name of subject to process
    :param hand name of hand to process
    :return my_tests Array of AsteriskTestMetrics with tests&#34;&#34;&#34;

    my_tests = []
    for fname in generate_fname(subject_name, hand):
        _, subject, hand, translation, rotation, end = fname.split(&#34;_&#34;)
        number, _ = end.split(&#34;.&#34;)

        try:
            with open(fname, &#34;r&#34;) as csvfile:
                csv_file = csv.reader(csvfile, delimiter=&#39;,&#39;)
                obj_poses = []
                for i, row in enumerate(csv_file):
                    try:
                        obj_poses.append([float(row[1]), float(row[2]), float(row[3])])
                    except:
                        pass

                obj_poses = np.transpose(np.array(obj_poses))
                print(f&#34;{fname}\n x {obj_poses[0,-1]} y {obj_poses[1, -1]} t {obj_poses[2, -1]}&#34;)

                hand_name = hand
                trial_translation = translation
                trial_rotation = rotation
                trial_number = int(number)-1
                name = f&#34;{subject_name}_{hand_name}_Trial{trial_number}&#34;

                while len(my_tests) &lt;= trial_number:
                    my_tests.append(AsteriskTestMetrics2D())

                my_tests[trial_number].test_name = f&#34;{subject_name}_{hand_name}&#34;
                dists = my_tests[trial_number].process_file(name, trial_translation, trial_rotation, obj_poses)

                print(f&#34;{dists}\n&#34;)
        except FileNotFoundError:
            print(f&#34;File not found: {fname}&#34;)

    return my_tests</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.run_tests"><code class="name flex">
<span>def <span class="ident">run_tests</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def run_tests():
    my_asterisk_tests = AsteriskTestMetrics2D()

    my_asterisk_tests.test_translation()
    my_asterisk_tests.test_rotation()
    my_asterisk_tests.test_twist_translation()

    my_asterisk_tests.write_test_results(&#34;test_results.csv&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_rotation_test"><code class="name flex">
<span>def <span class="ident">add_rotation_test</span></span>(<span>self, name, in_which, poses_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the translation test
:param in_which is Clockwise or Counterclockwise
:param poses_obj is a 3xn matrix of x,y,theta poses
:returns Percentage distance traveled, percentage error last pose, overall path score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rotation_test(self, name, in_which, poses_obj):
    &#34;&#34;&#34;Add the translation test
    :param in_which is Clockwise or Counterclockwise
    :param poses_obj is a 3xn matrix of x,y,theta poses
    :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

    target_path = self.target_paths[&#34;Rotation&#34;][in_which]
    target_pose = target_path[-1]

    # Setup test results
    ret_dists = AsteriskTestResults(name, poses_obj, target_path)
    ret_dists.set_rotation_test(in_which)

    # Check that we&#39;re in at least roughly the right ballpark for the end pose
    last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
    dist_from_center = sqrt(last_pose_obj.x**2 + last_pose_obj.y**2)
    if dist_from_center &gt; 0.2:
        print(&#34;Warning: rotation test {} had big offset {}&#34;.format(in_which, dist_from_center))

    # Use mostly rotation error for distance
    scl_ratio = (0.01, 1 - 0.01)

    # Calculate distances
    ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;]
    ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

    ret_dists.dist_target = last_pose_obj.distance(target_pose)

    if ret_dists.end_target_index == 0:
        print(&#34;Warning: Closest pose was first pose&#34;)
        ret_dists.end_target_index += 1

    ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                          ret_dists.end_target_index,
                                                                          target_path,
                                                                          scl_ratio)

    self.test_results.append(ret_dists)
    return ret_dists</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_translation_test"><code class="name flex">
<span>def <span class="ident">add_translation_test</span></span>(<span>self, name, in_which, poses_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the translation test
:param name: str - name of test, eg, hand type
:param in_which is 0..7, which angle in the asterisk
:param poses_obj is a 3xn matrix of x,y,theta poses
:returns Percentage distance traveled, percentage error last pose, overall path score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_translation_test(self, name, in_which, poses_obj):
    &#34;&#34;&#34;Add the translation test
    :param name: str - name of test, eg, hand type
    :param in_which is 0..7, which angle in the asterisk
    :param poses_obj is a 3xn matrix of x,y,theta poses
    :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

    target_path = self.target_paths[&#34;Translation&#34;][in_which]
    target_pose = target_path[-1]

    # Setup test results
    ret_dists = AsteriskTestResults(name, poses_obj, target_path)
    ret_dists.set_translation_test(in_which)

    # Check that we&#39;re in at least roughly the right ballpark for the end pose
    last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
    n_total = poses_obj.shape[1]
    last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
    expected_angle = self.translation_angles[in_which]
    if last_pose_angle - expected_angle &gt; 180:
        last_pose_angle -= 360
    elif expected_angle - last_pose_angle &gt; 180:
        last_pose_angle += 360

    if abs(last_pose_angle - expected_angle) &gt; 65:
        print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which, last_pose_angle,
                                                                                      self.translation_angles[
                                                                                          in_which]))

    # Use mostly translation for distance
    scl_ratio = (1- 0.01, 0.01)
    ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
    ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

    ret_dists.dist_target = last_pose_obj.distance(target_pose, scl_ratio)

    if ret_dists.end_target_index == 0:
        print(&#34;Warning: Closest pose was first pose&#34;)
        ret_dists.end_target_index += 1

    ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                          ret_dists.end_target_index,
                                                                          target_path,
                                                                          scl_ratio)
    self.test_results.append(ret_dists)
    return ret_dists</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_twist_translation_test"><code class="name flex">
<span>def <span class="ident">add_twist_translation_test</span></span>(<span>self, name, in_which_rot, in_which_trans, poses_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the translation test
:param in_which_rot is 0 or 1, clockwise or counter
:param in_which_trans is 0..7, which angle in the asterisk
:param poses_obj is a 3xn matrix of x,y,theta poses
:returns Percentage distance traveled, percentage error last pose, overall path score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_twist_translation_test(self, name, in_which_rot, in_which_trans, poses_obj):
    &#34;&#34;&#34;Add the translation test
    :param in_which_rot is 0 or 1, clockwise or counter
    :param in_which_trans is 0..7, which angle in the asterisk
    :param poses_obj is a 3xn matrix of x,y,theta poses
    :returns Percentage distance traveled, percentage error last pose, overall path score&#34;&#34;&#34;

    target_path = self.target_paths[&#34;Twist_translation&#34;][in_which_rot][in_which_trans]
    target_pose = target_path[-1]

    # Setup test results
    ret_dists = AsteriskTestResults(name, poses_obj, target_path)
    ret_dists.set_twist_translation_test(in_which_trans, in_which_rot)

    # Check that we&#39;re in at least roughly the right ballpark for the end pose
    last_pose_obj = Pose2D(poses_obj[0, -1], poses_obj[1, -1], poses_obj[2, -1])
    n_total = poses_obj.shape[1]

    last_pose_angle = 180.0 * arctan2(last_pose_obj.y, last_pose_obj.x) / pi
    expected_angle = self.translation_angles[in_which_trans]
    if last_pose_angle - expected_angle &gt; 180:
        last_pose_angle -= 360
    elif expected_angle - last_pose_angle &gt; 180:
        last_pose_angle += 360

    if abs(last_pose_angle - expected_angle) &gt; 65:
        print(&#34;Warning: Translation {} detected bad last pose {}, expected {}&#34;.format(in_which_trans, last_pose_angle,
                                                                                      self.translation_angles[
                                                                                          in_which_trans]))

    # Use mostly translation for distance
    scl_ratio = (1 - 0.01, 0.01)

    ret_dists.dist_along_translation = sqrt(max([poses_obj[0, i_p]**2 + poses_obj[1, i_p]**2 for i_p in range(0, n_total)]))
    ret_dists.dist_along_rotation = abs(last_pose_obj.theta) / AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;]

    ret_dists.end_target_index = self._narrow_target(last_pose_obj, target_path, scl_ratio)

    ret_dists.dist_target = last_pose_obj.distance(target_pose)

    if ret_dists.end_target_index == 0:
        print(&#34;Warning: Closest pose was first pose&#34;)
        ret_dists.end_target_index += 1

    ret_dists.dist_frechet, ret_dists.target_indices = self._frechet_dist(poses_obj,
                                                                          ret_dists.end_target_index,
                                                                          target_path,
                                                                          scl_ratio)
    ret_dists.target_paths = self.target_paths

    self.test_results.append(ret_dists)
    return ret_dists</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.get_test_results"><code class="name flex">
<span>def <span class="ident">get_test_results</span></span>(<span>self, att:AsteriskTestTypes.AsteriskTestTypes) >[<class'<a title="asterisk_test.AsteriskTestMetrics.AsteriskTestResults" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestResults">AsteriskTestResults</a>'>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the tests of that type
:param att Asterisk test type
:returns [AsteriskTestResults]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_test_results(self, att: AsteriskTestTypes)-&gt;[AsteriskTestResults]:
    &#34;&#34;&#34;Get all the tests of that type
    :param att Asterisk test type
    :returns [AsteriskTestResults] &#34;&#34;&#34;

    return [res for res in self.test_results if res.is_type(att)]</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_file"><code class="name flex">
<span>def <span class="ident">process_file</span></span>(<span>self, name:str, trial_type:str, ang_name:str, obj_poses)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the files, compute the metrics
:param name subject + hand + trial name
:param trial_type from asterisk_0_prompts, minus, plus, etc
:param ang_name from asterisk_0_prompts, none or a, b, c etc
:param obj_poses object poses
:returns Distances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_file(self, name: str, trial_type: str, ang_name: str, obj_poses):
    &#34;&#34;&#34;Read the files, compute the metrics
    :param name subject + hand + trial name
    :param trial_type from asterisk_0_prompts, minus, plus, etc
    :param ang_name from asterisk_0_prompts, none or a, b, c etc
    :param obj_poses object poses
    :returns Distances&#34;&#34;&#34;

    trial_direction = ord(trial_type[0]) - ord(&#39;a&#39;)
    if ang_name == &#34;m15&#34;:
        dists = self.add_twist_translation_test(name, 1, trial_direction, obj_poses)

    elif ang_name == &#34;p15&#34;:
        dists = self.add_twist_translation_test(name, 0, trial_direction, obj_poses)

    elif ang_name == &#34;cw&#34;:
        dists = self.add_rotation_test(name, 1, obj_poses)

    elif ang_name == &#34;ccw&#34;:
        dists = self.add_rotation_test(name, 0, obj_poses)

    else:
        dists = self.add_translation_test(name, trial_direction, obj_poses)

    return dists</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.reset_test_results"><code class="name flex">
<span>def <span class="ident">reset_test_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Zero out the results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_test_results(self):
    &#34;&#34;&#34;Zero out the results&#34;&#34;&#34;

    self.test_results = []</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_rotation"><code class="name flex">
<span>def <span class="ident">test_rotation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make fake translation data and add it
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_rotation(self):
    &#34;&#34;&#34; Make fake translation data and add it
    :rtype: None &#34;&#34;&#34;
    from numpy.random import uniform

    n_poses = 50
    obj_poses = zeros([3, n_poses])
    noise_x = uniform(-0.1, 0.1, n_poses)
    noise_y = uniform(-0.1, 0.1, n_poses)
    noise_ang = uniform(-0.5, 0.5, n_poses)

    for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Clockwise&#34;], n_poses)):
        obj_poses[0, i_ang] = noise_x[i_ang]
        obj_poses[1, i_ang] = noise_y[i_ang]
        obj_poses[2, i_ang] = ang + noise_ang[i_ang]

    dists = self.add_rotation_test(&#34;Test&#34;, 0, obj_poses)
    print(&#34;Rotation, angle {0}, distances {1}&#34;.format(&#34;Clockwise&#34;, dists))
    for i_ang, ang in enumerate(linspace(0, AsteriskTestTypes.rotation_directions[&#34;Counterclockwise&#34;], n_poses)):
        obj_poses[2, i_ang] = ang + noise_ang[i_ang]
    dists = self.add_rotation_test(&#34;Test&#34;, 1, obj_poses)
    print(&#34;Rotation, angle {0}: {1}&#34;.format(&#34;Counterclockwise&#34;, dists))</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_translation"><code class="name flex">
<span>def <span class="ident">test_translation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make fake translation data and add it
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_translation(self):
    &#34;&#34;&#34; Make fake translation data and add it
    :rtype: None
    &#34;&#34;&#34;
    from numpy.random import uniform

    n_poses = 100
    obj_poses = zeros([3, n_poses])
    noise_x = uniform(-0.1, 0.1, (8, n_poses))
    noise_y = uniform(-0.1, 0.1, (8, n_poses))
    noise_ang = uniform(-5, 5, (8, n_poses))

    print(&#34;Testing translations&#34;)
    for i_ang, ang in enumerate(self.translation_angles):
        for i_p, div in enumerate(linspace(0, 1, n_poses)):
            obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
            obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
            obj_poses[2, i_p] = noise_ang[i_ang, i_p]

        dists = self.add_translation_test(&#34;Test&#34;, i_ang, obj_poses)
        print(&#34;Translation, angle {0}: {1}&#34;.format(ang, dists))</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_twist_translation"><code class="name flex">
<span>def <span class="ident">test_twist_translation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make fake translation data and add it
:rtype: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_twist_translation(self):
    &#34;&#34;&#34; Make fake translation data and add it
    :rtype: None &#34;&#34;&#34;
    from numpy.random import uniform

    n_poses = 100
    obj_poses = zeros([3, n_poses])
    noise_x = uniform(-0.1, 0.1, (8, n_poses))
    noise_y = uniform(-0.1, 0.1, (8, n_poses))
    noise_ang = uniform(-5, 5, (8, n_poses))

    for i_ang, ang in enumerate(self.translation_angles):
        for i_p, div in enumerate(linspace(0, 1, n_poses)):
            obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
            obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
            obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Clockwise&#34;] + noise_ang[i_ang, i_p]

        dists = self.add_twist_translation_test(&#34;Test&#34;, 0, i_ang, obj_poses)
        print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Clockwise&#34;, ang, dists))

    for i_ang, ang in enumerate(self.translation_angles):
        for i_p, div in enumerate(linspace(0, 1, n_poses)):
            obj_poses[0, i_p] = div * cos(pi*ang/180) + noise_x[i_ang, i_p]
            obj_poses[1, i_p] = div * sin(pi*ang/180) + noise_y[i_ang, i_p]
            obj_poses[2, i_p] = AsteriskTestTypes.twist_directions[&#34;Counterclockwise&#34;] + noise_ang[i_ang, i_p]

        dists = self.add_twist_translation_test(&#34;Test&#34;, 1, i_ang, obj_poses)
        print(&#34;Twist {} Translation, angle {}: {}&#34;.format(&#34;Counterclockwise&#34;, ang, dists))</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.write_test_results"><code class="name flex">
<span>def <span class="ident">write_test_results</span></span>(<span>self, fname)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the test results out to a csv file
:param fname: str
:rtype none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_test_results(self, fname):
    &#34;&#34;&#34; Write the test results out to a csv file
    :param fname: str
    :rtype none&#34;&#34;&#34;
    with open(fname, &#34;w&#34;) as f:
        csv_f = csv.writer(f, delimiter=&#39;,&#39;)
        AsteriskTestResults.write_header_data(csv_f)
        for t in self.test_results:
            t.write_data(csv_f)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestResults"><code class="flex name class">
<span>class <span class="ident">AsteriskTestResults</span></span>
<span>(</span><span>name, in_obj_poses:<built-infunctionarray>, in_target_path:[<class'<a title="asterisk_test.AsteriskTestMetrics.Pose2D" href="#asterisk_test.AsteriskTestMetrics.Pose2D">Pose2D</a>'>])</span>
</code></dt>
<dd>
<div class="desc"><p>distances, angles, index in test
:param name - trial file name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsteriskTestResults(AsteriskTestTypes):
    status_values = {&#34;Successful&#34;, &#34;Unsuccessful&#34;, &#34;Not_tried&#34;}
    def __init__(self, name, in_obj_poses: np.array, in_target_path: [Pose2D]):
        &#34;&#34;&#34;distances, angles, index in test
        :param name - trial file name&#34;&#34;&#34;
        self.test_name = name

        # Actual distances
        self.dist_target = nan
        self.dist_frechet = nan
        self.dist_along_translation = nan
        self.dist_along_rotation = nan

        # Data for Frechet distance
        self.end_target_index = -1
        self.target_indices = []

        # Save data
        self.obj_poses = in_obj_poses.copy()  # Copy because re-written each time
        self.target_path = in_target_path # These should be stable

    def __str__(self):
        &#34;&#34;&#34;Print results&#34;&#34;&#34;
        ret_str = super().__str__()
        if self.end_target_index == -1:
            ret_str = ret_str + &#34;, no result&#34;
        if self.dist_target is not nan:
            ret_str = ret_str + &#34; Target: {0:0.3f}&#34;.format(self.dist_target)
        if self.dist_along_translation is not nan:
            ret_str = ret_str + &#34; D Trans: {0:0.3f}&#34;.format(self.dist_along_translation)
        if self.dist_along_rotation is not nan:
            ret_str = ret_str + &#34; D Rot: {0:0.3f}&#34;.format(self.dist_along_rotation)
        if self.dist_frechet is not nan:
            ret_str = ret_str + &#34; D Frec: {0:0.3f}&#34;.format(self.dist_frechet)
        return ret_str

    @staticmethod
    def write_header_data(f):
        &#34;&#34;&#34; Header row for csv file &#34;&#34;&#34;
        col_names = [&#34;Name&#34;, &#34;Type&#34;, &#34;TranslationName&#34;, &#34;RotationName&#34;, &#34;TwistName&#34;]
        col_names.extend([&#34;DistToTarget&#34;, &#34;DistAlongTranslation&#34;, &#34;DistAlongRotation&#34;, &#34;FrechetDistance&#34;])
        col_names.extend([&#34;LastIndex&#34;, &#34;Indices&#34;])
        f.writerow(col_names)

    def write_data(self, f):
        &#34;&#34;&#34; Write out data to a csv file
        :param f - csv file writer&#34;&#34;&#34;

        row_data = []
        row_data.append(self.test_name)
        row_data.append(self.get_test_name())
        row_data.append(self.get_translation_name())
        row_data.append(self.get_rotation_name())
        row_data.append(self.get_twist_name())
        row_data.append(self.dist_target)
        row_data.append(self.dist_along_translation)
        row_data.append(self.dist_along_rotation)
        row_data.append(self.dist_frechet)
        row_data.append(self.end_target_index)
        for i in self.target_indices:
            row_data.append(f&#34;{i}&#34;)

        f.writerow(row_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>AsteriskTestTypes.AsteriskTestTypes</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.status_values"><code class="name">var <span class="ident">status_values</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_header_data"><code class="name flex">
<span>def <span class="ident">write_header_data</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Header row for csv file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_header_data(f):
    &#34;&#34;&#34; Header row for csv file &#34;&#34;&#34;
    col_names = [&#34;Name&#34;, &#34;Type&#34;, &#34;TranslationName&#34;, &#34;RotationName&#34;, &#34;TwistName&#34;]
    col_names.extend([&#34;DistToTarget&#34;, &#34;DistAlongTranslation&#34;, &#34;DistAlongRotation&#34;, &#34;FrechetDistance&#34;])
    col_names.extend([&#34;LastIndex&#34;, &#34;Indices&#34;])
    f.writerow(col_names)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_data"><code class="name flex">
<span>def <span class="ident">write_data</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Write out data to a csv file
:param f - csv file writer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_data(self, f):
    &#34;&#34;&#34; Write out data to a csv file
    :param f - csv file writer&#34;&#34;&#34;

    row_data = []
    row_data.append(self.test_name)
    row_data.append(self.get_test_name())
    row_data.append(self.get_translation_name())
    row_data.append(self.get_rotation_name())
    row_data.append(self.get_twist_name())
    row_data.append(self.dist_target)
    row_data.append(self.dist_along_translation)
    row_data.append(self.dist_along_rotation)
    row_data.append(self.dist_frechet)
    row_data.append(self.end_target_index)
    for i in self.target_indices:
        row_data.append(f&#34;{i}&#34;)

    f.writerow(row_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.Pose2D"><code class="flex name class">
<span>class <span class="ident">Pose2D</span></span>
<span>(</span><span>in_x=0, in_y=0, in_theta=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Pose in 2 dimensions
:param in_x x location
:param in_y y location
:param in_theta rotation angle, in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pose2D:
    def __init__(self, in_x=0, in_y=0, in_theta=0):
        &#34;&#34;&#34; Pose in 2 dimensions
        :param in_x x location
        :param in_y y location
        :param in_theta rotation angle, in degrees&#34;&#34;&#34;

        self.x = in_x
        self.y = in_y
        self.theta = in_theta

    def distance(self, pose, scl_ratio=(0.5, 0.5)):
        &#34;&#34;&#34;Difference between self and another pose
        :type pose: Pose2D
        :param pose another Pose2D
        :param scl_ratio - how much to scale distance and rotation error by
        :returns a number&#34;&#34;&#34;

        # Standard euclidean distance, scaled by sin(45)
        dist_trans = sqrt((self.x - pose.x) ** 2 + (self.y - pose.y) ** 2) / sin(pi/4)
        # set up 20 deg of error as approximately 1 unit of translation error
        ang_rot = abs(self.theta - pose.theta)
        if ang_rot &gt; 180:
            ang_rot -= 180
        dist_rot = (ang_rot / 45.0)

        # return the average
        return scl_ratio[0] * dist_trans + scl_ratio[1] * dist_rot

    def lin_interp(self, pose, t):
        &#34;&#34;&#34; linearly interpolate the pose values
        :param pose pose to interpoloate to Pose2D
        :param t a number between 0 and 1
        :return the interpolated pose Pose2D&#34;&#34;&#34;
        return Pose2D(self.x + t * pose.x, self.y + t * pose.y, self.theta + t * pose.theta)

    def __str__(self):
        return &#34;x : {0:.2f}, y : {1:.2f}, theta : {2}&#34;.format(self.x, self.y, self.theta)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="asterisk_test.AsteriskTestMetrics.Pose2D.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, pose, scl_ratio=(0.5, 0.5))</span>
</code></dt>
<dd>
<div class="desc"><p>Difference between self and another pose
:type pose: Pose2D
:param pose another Pose2D
:param scl_ratio - how much to scale distance and rotation error by
:returns a number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, pose, scl_ratio=(0.5, 0.5)):
    &#34;&#34;&#34;Difference between self and another pose
    :type pose: Pose2D
    :param pose another Pose2D
    :param scl_ratio - how much to scale distance and rotation error by
    :returns a number&#34;&#34;&#34;

    # Standard euclidean distance, scaled by sin(45)
    dist_trans = sqrt((self.x - pose.x) ** 2 + (self.y - pose.y) ** 2) / sin(pi/4)
    # set up 20 deg of error as approximately 1 unit of translation error
    ang_rot = abs(self.theta - pose.theta)
    if ang_rot &gt; 180:
        ang_rot -= 180
    dist_rot = (ang_rot / 45.0)

    # return the average
    return scl_ratio[0] * dist_trans + scl_ratio[1] * dist_rot</code></pre>
</details>
</dd>
<dt id="asterisk_test.AsteriskTestMetrics.Pose2D.lin_interp"><code class="name flex">
<span>def <span class="ident">lin_interp</span></span>(<span>self, pose, t)</span>
</code></dt>
<dd>
<div class="desc"><p>linearly interpolate the pose values
:param pose pose to interpoloate to Pose2D
:param t a number between 0 and 1
:return the interpolated pose Pose2D</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lin_interp(self, pose, t):
    &#34;&#34;&#34; linearly interpolate the pose values
    :param pose pose to interpoloate to Pose2D
    :param t a number between 0 and 1
    :return the interpolated pose Pose2D&#34;&#34;&#34;
    return Pose2D(self.x + t * pose.x, self.y + t * pose.y, self.theta + t * pose.theta)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="asterisk_test" href="index.html">asterisk_test</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D">AsteriskTestMetrics2D</a></code></h4>
<ul class="">
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_rotation_test" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_rotation_test">add_rotation_test</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_translation_test" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_translation_test">add_translation_test</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_twist_translation_test" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.add_twist_translation_test">add_twist_translation_test</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.get_test_results" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.get_test_results">get_test_results</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.metric_names" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.metric_names">metric_names</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_file" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_file">process_file</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_files" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.process_files">process_files</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.reset_test_results" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.reset_test_results">reset_test_results</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.run_tests" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.run_tests">run_tests</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_rotation" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_rotation">test_rotation</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_translation" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_translation">test_translation</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_twist_translation" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.test_twist_translation">test_twist_translation</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.translation_angles" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.translation_angles">translation_angles</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.write_test_results" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestMetrics2D.write_test_results">write_test_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestResults" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestResults">AsteriskTestResults</a></code></h4>
<ul class="">
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.status_values" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestResults.status_values">status_values</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_data" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_data">write_data</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_header_data" href="#asterisk_test.AsteriskTestMetrics.AsteriskTestResults.write_header_data">write_header_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="asterisk_test.AsteriskTestMetrics.Pose2D" href="#asterisk_test.AsteriskTestMetrics.Pose2D">Pose2D</a></code></h4>
<ul class="">
<li><code><a title="asterisk_test.AsteriskTestMetrics.Pose2D.distance" href="#asterisk_test.AsteriskTestMetrics.Pose2D.distance">distance</a></code></li>
<li><code><a title="asterisk_test.AsteriskTestMetrics.Pose2D.lin_interp" href="#asterisk_test.AsteriskTestMetrics.Pose2D.lin_interp">lin_interp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>